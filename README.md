# Plant2Code

Библиотека для преобразования plantuml кода в исполняемый С-код для проверки работоспособности устройств/агрегатов.

Процесс переноса
- [x] Считывание CSV-таблиц с сигналами
	- [x] Пропуск резервных данных
	- [x] Окончание таблиц резервным сигналом или пустой строкой
- [x] Считывание plantuml-кода
	- [x] Допуск пустых строк после @enduml
	- [x] Разбор plantuml на составные блоки
		- [x] Игнорирование "служебных" строк
		- [x] Блоки комментариев
		- [x] Блок вычисления
			- [x] Обработка вложенных комментариев
			- [x] Раскрытие блоков "..."
		- [x] Блок вызова функции
			- [x] Обработка вложенных комментариев
		- [x] Блоки ссылок
			- [x] Блок начала алгоритма
			- [x] Блоки окончания алгоритма
			- [x] Блоки блок "goto"
		- [x] Служебные блоки
			- [x] if-else + elseif
			- [x] switch-case
			- [x] while
	- [x] Считывание шапки алгоритма
- [ ] Проверка сигналов plantuml-кода
- [ ] Проверка корректности plantuml-кода
- [ ] Генератор С-кода

## Исходные данные

### CSV-таблицы

Используются для заполнения информации о сигналах.

Библиотека предусматривает использование:
- Входных сигналов.
- Выходных сигналов.
- Внутренних сигналов.
- Констант.
- Таймеров.
- Произвольных типов данных (структур).

Сигналы могут быть представлены в одной CSV-таблице (не реализовано в прошлой версии). Определение типа сигнала посходит по префиксу названия, которые задаются в при настройке считывающего класса (не реализовано в прошлой версии. Используется привязка к конкретному префиксу сигнала.). 

Колонки, содержащие необходимые атрибуты также определяются при настройке считывающего класса (не реализовано в прошлой версии. Используется привязка к конкретному названию столбца.).

Дальнейшее описание основывается на текущей реализации, при изменении/доработке дальнейший текст не действителен.

#### Возможные столбцы таблицы

- Название переменной ("Обозначение", "Обозначение состояния", "Обозначение сигнала")
- Текстовое описание ( "Наименование", "Название сигнала", "Название состояния)
    - Данные с описанием "Резерв" игнорируются 
- Тип переменной ("Тип данных")
- Значение переменной ("Значение")

#### Префиксы данных

Использующиеся префиксы:
- Входных сигналов - X.
- Выходных сигналов - Y.
- Внутренних сигналов - Z.
- Констант - C.
- Таймеров - T.
- Произвольных типов данных (струтур) - S.


#### Содержание CSV-таблицы с сигналами

- Колонка с типом данных:
    - Используются произвольно-задаваемые типы (Работа существующего варианта предусматривает типы: (U)Int8, (U)Int16, (U)Int32, (U)Int64 и float).
    - Допускает использование массивов Int8[<Размер>].
- Текстовое описание сигнала (опционально).
- Название переменной:
    - Допускает использование индекса массива Int8[0], при объявлении массива "по-кускам". При подобном объявлении массив в типе данных не указывается.
    - Допускает использование полного размера, при объявления массива за раз <Название сигнала>[0..2].При подобном объявлении массив в типе данных указывается (в данном случае <Размер> = 3).

#### Содержание CSV-таблицы со структурами

См. Содержание CSV-таблицы с сигналами.

Дополнительно допускает объявление типа структуры, при котором поля с типом данных не заполняется.

#### Содержание CSV-таблицы с константами

- Текстовое описание константы (опционально).
- Название переменной. Использование массивов не допускается.
- Значение переменной (предполагается использование численных констант. + Вычисления, которые можно провести в С).

#### Содержание CSV-таблицы с таймерами

- Текстовое описание сигнала (опционально).
- Название переменной. Использование массивов не допускается.

#### Примеры таблиц

См example/CSV/

### PlantUml

Предполагается, что plantuml написан корректно.

#### Игнорируемые строки

Игнорируются строки начинаемые с:
- !
- @
- detach

#### Комментарии plantuml

Комментарии (как однострочные, так и многострочные) сохраняются для дальнейшего переноса в C-код. (Не реализовано в старой версии).
При необходимости задаются комментарии (задаются без символов комментария), которые игнорируются. Игнорируемые комментарии
- blank

Для сопроводительных комментариев внутри блоков используется директива \$comment(). (В старой версии подобный комментарий распространяется исключительно на блоки вычисления, где комментарий выделяется директивами \$comment_start и \$comment_end)
```
!function $comment()
!return ""
!endfunction
```

#### Блоки вычисления (:])

- Строка/строки до первого вычисления считаются комментариями и НЕ выделяются директивой \$comment()
- Комментарии не должны содержать символ '='
- Допускается использование вложенных комментариев
- Каждое новое вычисление должно начинаться с переноса строки
- Внутри вычислений (после символа '=') не должно содержаться символа '='
	- Т.е вычисление L1 = (L0 = 2) + 1 должно записываться как :L0 = 2\nL1 = L0 + 1]
- Допускается использование символа "..."
	- Допускается изменение только одного параметра (оказалось невостребованным в прошлой версии)
	- Изменение допускается только для l-value (оказалось невостребованным в прошлой версии)
	- При использовании с переменными символ "..." размещается на отдельной строке (см. примеры)
	- При использовании в массиве символ "..." размещается внутри [0...2] (см. примеры)

#### Блоки функций (:\|)
- Допускается вызывать несколько функций в одном блоке (не реализовано в старой версии)
- В сопроводительных комментариях использование \$comment() опционально
- Структура вызова:
```
	:<Комментарий>"Название функции (arg1, arg2, ...) -> (return1, return2, ...)"|
```
- Комментарий - опциональная часть
- Если функция не имеет аргументов, то для вызова применяется только "Название функции"
- В аргументах не должно быть вычислений
- Перенос названия функции должен быть на месте символа ' ', в противном случае название функции считается некорректно
- Название функции не должно содержать символа "

#### Блоки ссылок (:\;)

- Блоки алгоритма должны находится в одном файле
- Первый блок алгоритма должен начинаться и оканчиваться с анонимной ссылки
- Последующие блоки должны начинаться и оканчиваться именованной ссылкой
- Название ссылки, в рамках файла, должно быть уникальным.

Обозначение ссылок:
- для начала ссылки используется "Вход <Название ссылки>"
- для перехода по ссылке используется "<Название ссылки>"
- для начала ссылки используется "Выход <Название ссылки>"

#### Блоки if/if-else

Общий вид блока:
```
if (<Текстовое описание условия>?<Условие в виде кода>) then (да)
	'Логика на "да"
else (нет)
	'Логика на "нет"
endif
```
или
```
if (<Текстовое описание условия>?<Условие в виде кода>) then (да)
	'Логика на "да"
else if (<Текстовое описание условия>?<Условие в виде кода>) then (да)
	'Логика на "да"
else (нет)
	'Логика на "нет"
endif
```
Обязательное содержание:
- Всегда должен содержать блок "else". Если логика выполнения блока "else" отсутствует, то блок заполняется следующим образом:
	```
	if (<Текстовое описание условия>?<Условие в виде кода>) then (да)
		'Логика на "да"
	else (нет)
		'blank
	endif
	```
	При подобном выполнении генерация пустого блока else будет исключена из генерации С-кода.

- Блок "else if" может быть записан как "elseif".
- Окончание блоков "then (да)" и "(нет)" обязательно.
- Отделение <Текстовое описание условия> от <Условие в виде кода> символом '?' обязательно.
- <Текстовое описание условия> обязательно.

#### Блок switch-case
Общий вид блока:
```
switch (<Текстовое описание условия>)
case (<Условие_1 в виде кода>)
	'Логика, выполняемая при условии
case (<Условие_2 в виде кода>) 
	'Логика, выполняемая при условии
case (<Условие_3 в виде кода>)
	'Логика, выполняемая при условии
case (<Условие_4 в виде кода>)
	'Логика, выполняемая при условии
case (<Условие_5 в виде кода>)
	'Логика, выполняемая при условии
endswitch
```

Блок "switch" имеет в себе только <Текстовое описание условия>. Также знак '?' в конце <Текстовое описание условия> является опциональным.
Блок "case" только <Условие в виде кода>

При необходимости генерации default в условие в блоке "case" необходимо оставить пустым (не реализовано в прошлой версии).

#### Блок while

Общий вид блока:
```
while (<Текстовое описание условия>?<Условие в виде кода>) is (да)
	'Логика на "да"
endwhile (нет)
```

Обязательное содержание:
- Окончание блоков "is (да)" и "(нет)" обязательно.
- Отделение <Текстовое описание условия> от <Условие в виде кода> символом '?' обязательно.
- <Текстовое описание условия> обязательно.

#### Шапки алгоритмов

Шапка состоит из:


Объявления шапки:
- Короткое
	- Для объявления используются слова: "note right:","note left:","note up:","note down:"
	- Содержит только название алгоритма
- Полное
	- Для объявления используются слова: "note right","note left","note up","note down"
	- Содержит:
		- Названия алгоритма (обязательный элемент)
		- Аргументов алгоритма:
			- Входные аргументы (опциональный элемент): "Параметры:"
			- Локальные аргументы (опциональный элемент):  "Локальные переменные:"
			- Выходные аргументы (опциональный элемент): "Возвращаемые значения:"
		- Примечаний (опциональный элемент): "Примечание:" или "Примечания:"
	- Для обозначения окончания шапки используется "end note"

Аргументы объявляются следующим образом:
- Для сигналов/переменных (объявление доступно для всех 3х типов аргументов):
	```
	<Название сигнала>: <Тип сигнала> - <Описание сигнала>
	```
- Для таймеров (объявление доступно входным и выходным аргументам):
	```
	<Название таймера> - <Описание таймера>
	```

Перенос строк (через '\n') с объявлением сигналов допускается только в <Описание сигнала>/<Описание таймера>. При необходимости переноса в другом месте должна использоваться директива "%newline()" (Через директиву "%newline()" перенос разрешен в любом месте). 
*В старой версии переносы допускаются только у названия алгоритма. Директива "%newline()" не поддерживается*.

*Старая версия регулирует названия сигналов (удалено из-за последнего проекта):*
	- *Входные аргументы - P<номер сигнала>*
	- *Локальные аргументы - L<номер сигнала>* 
	- *Выходные аргументы - R<номер сигнала>*

Шапка алгоритма может встречаться несколько раз - в разных частях алгоритма (ссылки). При повторной встрече название алгоритма, если оно повторно объявлено не будет считано. 
В следующих алгоритмах допускается объявление новых, еще не объявленных в шапках, сигналов (в старой версии допускается дообъявление только локальных сигналов). Однако такие сигналы будут доступны всем частям алгоритмов.


Название алгоритма не должно содержать символа ".



#### Примеры plantuml

См example/plantuml/
### Генератор C-кода